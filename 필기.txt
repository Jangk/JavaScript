디버깅 실행은 html에서만 할것.
자바스크립트에서 실행시 luanch.js 생성되는데 이게 있으면 로컬 호스트 연결이 안됨.


기본 디폴트
  <!DOCTYPE html>                                                                 // 이 문서가 html이라는 것을 알림
  <html lang="ko">                                                                // 언어 ko로 설정
  <head>
  	<meta charset="UTF-8">                                                      // 유니코드 
  	<meta name="viewport" content="width=device-width, initial-scale=1.0">      // 
  	<meta http-equiv="X-UA-Compatible" content="ie=edge">
  </head>


html
  <button 버튼클래스명 = "btn" onclick="실행할 내용">출력내용</button>               // 버튼 생성 html에서 작동
  <div id = "식별ID">내용</div>                                                    // 그냥 출력 예약어
  <br>                                                                            // 줄 바꿈


단위 
    em = 몇 배 
    %  = 몇 퍼센트
    px = 몇 픽셀


폰트 
    <style>
    body
    {
        font-size = 13.em;                  // 바디의 폰트 사이즈를 13배로 설정.
        font-align = center;                // 폰트의 정렬을 가운데 정렬로 설정.
    }
    </style>


  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 자바 스크립트 

자료형
    - 기본형(원시형)
      * number      : 숫자 (여긴 정수,실수 구분없음 ? ) 
      * string      : 문자열
      * boolean     : 참, 거짓
      * undefineed  : 값을 지정하지 않았을 때 가지는 자료형
      * null        : 자료형에 맞지않은 값을 넣으면 지정되는 자료형
    - 복합형
      * object      : 함수와 속성이 포함된 자료형 ( 클래스 ?)
      * array       : 배열 (배열도 객체라는 듯 ?)


      var 호이스팅  : 자바 스크립트에선 var선언이 사용되는 곳보다 밑에 있어도 사용할 수 있는데 
                     그걸 호이스팅이라고함.(끌어올려 사용 ?)  다른 변수는 호이스팅 불가능.
      var          : 지역 변수. 특이하게 재선언할 수 있다. 마지막에 선언한 수로 덮어씌움
                     ex) var a =1 ; var a= 5;
      let 변수명;   : {}범위를 벗어날수 없게하는 예약어(var의 단점보완용으로 나옴)
                      * 블록 변수라고 함.(ES6 부터 나온기능)
                      * var보다 let을 쓸것.
      const 변수명; : c++ 상수랑 동일. 
      [변수명]      : 컴퓨티드 프로퍼티 == 변수명에 해당하는 값이 대입됨. 식을 넣을 수 도 있음
                      ex) let name = "이름"
                          const name ={
                            [name] : "철수",          // [name]에 이름 이 대입됨.
                            age : 30
                          }
                          let number = [1+5];        // 식을 넣을 수 있음 . 결과값은 6
  
  
객체 
   Object.assign({초기값}, 복사할 객체명);                     // 객체명1 = 객체명2은 얕은 복사가 되기 때문에, 
                                                                          깊은 복사된 객체를 반환.
                                                                * 초기값을 {}하면 전부 복사가되고, 초기값에 값을 넣으면
                                                                  넣은 초기값 + 복사할 객체의 값이 전부 포함된 객체가 반환됨.
                                                                * 객체의 키값이 같다면 덮어씀.
                                                                * 복사할 객체를 여러개 할 수도 있음.
                                                                  ex) Object.assign({}, 객체1, 객체2);
                                                                      - 3개다 합해진 객체를 리턴함.
  Object.Keys(객체명);                                        // 객체의 키값들을 문자열 배열로 만들어 반환함.  
  Object.Values(객체명);                                      // 객체의 값들을   문자열 배열로 만들어 반환함. 
  Object.entries(객체명);                                     // 객체의 키와 값들을 각각의 배열로 가진 배열로 반환. 
                                                                ex) let arr = [
                                                                    [mon, "월"],        // 키, 값
                                                                    [tue, "화"]
                                                                ]
                                                                const result = Object.entries(arr);   // 배열도 객체.
                                                                결과 == result[0] ==["mon", "tue"];   // 키만 배열
                                                                        result[1] == ["월", "화"];     // 값만 배열
  Object.fromEntries(객체명);                                 // 객체의 키와 값을 묶은 배열을 가진 배열로 반환.
                                                                ex) let arr = [
                                                                    [mon, "월"],        // 키, 값
                                                                    [tue, "화"]
                                                                ]
                                                                const result = Object.fromEntries(arr); // 배열도 객체.
                                                                결과 == result[0] == ["mon", "월"];     // 키값 배열 1
                                                                        result[1] == ["tue", "화"];     // 값값 배열2
  Symbol("id");                                               // 코드에 단하나의 유일한 식별자로 사용할때 씀.
                                                                 id 값은 생략가능하고 키값을 심볼로 사용시 
                                                                 keys, valuses, entries 메소드에서는 인식하지않고,
                                                                 for in 구문도 인식하지않음.
                                                                 * 특정 객체에 원본을 건드리지않고 속성을 추가할 때 사용.
                                                                 ex) let a = symbol();
                                                                     let b = symbol();
                                                                      * a !== b    같은 심볼이지만 다른 값으로 인식.
  Symbol.for("id");                                           // 하나의 심볼만 보장받음. (없으면 생성, 있으면 심볼을 가져옴)
                                                                 * 전역 심볼 
                                                                 ex) let a = symbol.for("id");
                                                                     let b = symbol.for("id");
                                                                      * a === b    심볼이랑 달리 같은값으로 인식.
  Symbol.keyFor(전역심볼변수명);                                // 해당 전역 심볼의 설정한 ID값을 가져옴.
                                                                 * 전역 심볼만 값을 가져올 수 있음.
  일반심볼변수명.description;                                   // 그냥 심볼의 설정한 ID값 을 가져옴.
  Object.getOwnPropertySymbols(객체명);                        // 객체 내에 있는 심볼을 가져옴.
  Reflect.ownKeys(객체명);                                     // 객체에 있는 심볼 키값을 포함한 모든 키값을 반환함.

                                                                
연산자
    - 다른 연산자는 C랑 전부 같은데 2개만 더 추가됨. 즉 == 는 자료형을 무시하고, 값만 같으면 참. ex) 3 =="3"  참
      * ===         : 두값이 자료형까지 같은지 검사
      * !==         : 두값이 자료형까지 같지 않지 검사
      * +           : 변수끼리 연산이 연결 연산자로 사용됨                                    ex) 3+"10" == 310
                      나머지 사칙연산은 숫자로 연산해서 처리함(자동형변환).                    ex) "10"-7 == 3


    
함수         : 변수 호이스팅처럼 위에 선언되어있을 필요가없음. 정의만 어디든 있다면 사용가능함.
    익명 함수    : 변수에 함수를 넣어서 사용 
                  ex) var UnknowFunc = func(a,b){return a+b};
    즉시 실행함수 : 정의와 동시에 실행함.
                  ex) (function (매개변수가 잇다면 매개변수){실행 내용}(매개변수가 잇다면 매개변수));
    화살표 함수  : ES6부터 나온 함수 정의를 빨리하기 위해 나온 함수 정의 방법(중괄호가 없다)
                  ex) (매개변수)=>함수내용;
    var now     = new Date();                               // 날짜 관련 클래스 ?
	  var display = now.toLocaleTimeString();                 // 날짜 클래스에서 현재 시각을 문자열로 반환함.
    
    
    
    typeof 변수명;                                           // 해당 자료형을 조회하는 방법
    console.log("내용");                                    // 콘솔에 글을 띄움(웹에는 출력안됨)
    prompt("질문","기본 입력 값");                           // 내용과 함께 입력창이 뜨고, 입력된 값을 문자열로 리턴함.  
                                                               2번째 함수 인자는 생략 가능하고, 
                                                               입력 창에 기본 입력값이 설정되 있음(수정가능);


숫자 관련
    isNaN(확인할 값);                                       // isNaN으로만 NaN인지 확인할 수 있다.
    num.toString(진수 값);                                  // 해당 진수값(2, 8 16진수 등) 문자열로 명시적 형변환.
    parseInt(형변환을 할 값, 진수값);                        // 함수 인자의 값을 명시적 정수형으로 명시적 형변환
                                                              진수값 생략시 10진수로 표기.
                                                               * 앞부분부터 숫자 부분만 읽다가 문자열을 만나면 이떄까지
                                                                 읽은 부부만 정수로 바꾸고 반환함.
                                                               * 첫 부분이 문자면 NaN을 반환함.
    parseFloat(형변환을 할 값, 진수값);                        // 함수 인자의 값을 명시적 실수형으로 명시적 형변환
    Number(형변환을 할 값);                                  // 숫자로 변환.
    Math.random();                                          // 0에서 1사이의 무작위 값을 반환함.
    Math.ceil(숫자)                                          // 올림 
    Math.floor(숫자)                                         // 내림 
    Math.round(숫자)                                         // 반올림 
    Math.pi()                                                // 파이 값 
    Math.max(숫자1, 숫자2, 숫자3);                            // 함수 인자는 여러개 가능하고, 그 값중 가장 큰   값을 반환.
    Math.min(숫자1, 숫자2, 숫자3);                            // 함수 인자는 여러개 가능하고, 그 값중 가장 작은 값을 반환.
    Math.abs(숫자)                                           // 절대값
    Math.pow(숫자, 지수값);                                  // 제곱값
    Math.sqrt(숫자)                                         // 제곱근 값(루트)
    변수명.toFixed(소숫점 자릿수);                            // 소숫점 자릿수까지 반올림해서 표현.
                                                                * 0은 정수로 만듬
                                                                * 소수 자릿수보다 크면 나머지 0으로 채워줌.


배열 관련
    배열명1.concat(배열명2);                                  // 배열명1 기준으로 뒤에 배열명2를 연결함.
                                                                * 새로운 배열을 만드는거라 기존배열은 보존.
    배열명.join(값 사이에 들어갈 것.);                         // 배열의 값들은 전부 합쳐 문자열로 만듬.
                                                                * a.join();   
                                                                * [1,2,3,4,5]      "1,2,3,4,5"  
                                                                * a.join(":");   
                                                                * [1,2,3,4,5]      "1:2:3:4:5"  
    배열명.push(추가할 값);                                   // 배열 뒤에 값 추가하고 바뀐 배열 값의 갯수를 반환함.
    배열명.unshift(추가할 값);                                // 배열 앞에 값 추가하고 바뀐 배열 값의 갯수를 반환함.
    배열명.pop();                                            // 배열 뒤에 값 추출하고 반환함.
    배열명.shift();                                          // 배열 앞에 값 추출하고 반환함.
    배열명.slice(시작 인덱스 번호, 종료 인덱스 번호);           // 시작 인덱스 번호이상, 종료 인덱스 번호 미만의 값만 배열로 생성.
                                                                * 원본은 건들이지 않고 생성함.
                                                             // 시작 인덱스 번호만 있으면, 시작부터 끝까지 값을 배열로 생성.
    배열명.splice(시작 인덱스 번호, 삭제할 갯수);               // 시작 인덱스 번호부터 삭제할 갯수만큼 추출함.(원본 변함)
    배열명.splice(시작 인덱스 번호, 삭제할 갯수, 추가할 값);     // 시작 인덱스 번호부터 삭제한 값이 있던 장소에 추가할 값을 넣음
                                                                * 한개만 들어가며, 삭제할 갯수가 0 이면 시작 인덱스번호 뒤에
                                                                  추가할 값만 넣음.
    배열명.reduce((누산값, 현재요소값, 현재요소의index, 현재배열) => {
                  return 다음누산값;
          }, 초기누산값);)
                            // 초기 누산값 생략가능 (생략시 0)
                            // 안의 식에서 return 되는 값은 누산값에 반환됨.
                            ex) const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
                                const sum1 = numbers.reduce((accumulator, currentObject) => {
                                                            return accumulator + currentObject;
                                                          }, 0);                            // accumulator 초기값은 0
                                결과값은 sum1 == 55;
    배열명.indexOf("찾을 값", 시작 인덱스);                    // 시작인덱스부터 뒤로 찾고, 첫번째로 찾은 값의 인덱스를 반환.
    배열명.lastindexOf("찾을 값");                            // 뒤에서부터 첫번째로 찾은 값의 인덱스를 반환.
    배열명.include("값");                                     // 값이 배열내에 있으면 true, 없으면 false
    배열명.find(함수);                                        // 함수의 리턴값이 true일떄까지 찾은 값을 반환
    배열명.findIndex(함수);                                   // 함수의 리턴값이 true일떄까지 찾은 인덱스를 반환
                                                                * find 와 findIndex 모두 첫번쨰로 찾은 값만 리턴후 종료함.
                                                                * 해당 값을 못찾으면 undefined를 반환.
    배열명.filter(함수);                                      // 함수의 반환값이 true일때 반환된 값들을 배열로 반환함.
    배열명.map(함수);                                         // 함수의 특정기능을 실행하고 새로운 배열을 반환.
                                                                * ex)요소를 추가된 오브젝트를 추가함.
    배열명.reverse();                                         // 배열의 값을 순서를 반대로 바꿈.


문자열 관련                                                         
    문자열변수[인덱스];                                        // 인덱스 번호로 문자열의 특정문자를 조회할 순있지만 변경 불가.
    string.toUpperCase(문자열 변수);                          // 문자열 변수의 값 전부 대문자로 바꿈
    string.toLowerCase(문자열 변수);                          // 문자열 변수의 값 전부 소문자로 바꿈
    문자열변수.indexOf("찾는 문자열");                         // 찾는 문자열이 발견된 곳의 인덱스를 반환. 없으면 -1 반환.
    문자열변수.slice(시작인덱스, 종료인덱스);                   // 시작 인덱스부터 종료인덱스 전까지의 문자열 반환.
                                                                * 양수면 종료인덱스 까지, 음수면 뒤에서 부터 숫자까지
                                                                  생략 가능함(생략시 끝까지).
    문자열변수.subString(시작인덱스, 종료인덱스);               // 시작 인덱스부터 종료인덱스 전까지 문자열 값 반환.
                                                                * 여긴 음수 안됨;
    문자열변수.substr(시작인덱스, 갯수);                        // 시작 인덱스부터 갯수만큼 문자열 값 반환.
    문자열변수.trim();                                         // 문자열내에 있는 공백을 전부 제거.
    문자열변수.repeat(횟수);                                   // 횟수만큼 문자열 반복한걸 반환.
    문자열변수.codePointAt(확인할 문자 인덱스);                 // 해당 인덱스의 문자를 아스키 코드값 반환.
    문자열변수.fromCodePoint(아스키코드값);                     // 아스키 코드값을 문자열로 반환.

    



    document.write("<b><big>"+변수명);                      // 화면에 출력함    
                                                            * <b>   볼드(굵은 글씨체)
                                                            * <big> 큰 글씨
    document.querySelector("#선택할 Id값")                   // 선택할 ID값에 해당하는 값을 반환.
    document.querySelector(".선택할 class 이름")             // 선택할 class값에 해당하는 값 모두 반환.
    document.querySelector("#선택할 Id값").innerHTML ="내용" // 선택된 값에 HTML을 내용을 넣음. ??
    document.querySelector
                                                               * 엘리멘트 선택자 ?
    document.getElementById("id값");                        //  querySelector와 비슷하지만 훨씬 빠름.
    document.getElementsByClassName("class값");             // id값은 한개의 객체만 불러오지만, class값에 해당하는 것
                                                               전부 불러온다.
                                                               * dom 방식 선택자 ?
    alert();                                                // 메세지 박스
    
    
    /*  
        - html 요소, 속성, 노드 예시
        <p class = "headText">내용입니다</p1>
         * <p></p>    : 요소
           class      : 속성
           내용입니다  : 텍스트 노드
    */
    document.createElement("요소 이름");                     // 요소 노드 생성
    document.createTextNode("텍스트노드 이름");               // 텍스트 노드 생성
    document.createAttribute("속성명");                      // 속성 생성
    속성.value ="속성 값";                                   // 속성에 속성 값을 넣음.
                                                               ex)
                                                               let attr = document.createAttribute("class");
                                                               attr.value = "HeadText";
    요소.appendChild(자식으로 들어갈 노드)                    // 요소의 자식으로 만듬.
    요소.SetAttributeNode("속성");                           // 속성의 요소 노드로 들어감.
    document.body                                           // HTML의 <body></body> 속성을 반환함.

    addEventListener("이벤트명", 함수, 캡쳐링 boolean 값);    // true  = 캡처링  (부모요소만 눌려야 작동하는게 아니라 자식을
                                                                                눌려도 작동)
                                                                false = 버블링  (자식요소만 눌려야 작동하는게 아니라 부모를
                                                                                눌려도 작동)
     * 노드 삭제는 부모에서만 가능하다.
     노드.parentNode                                         // 노드의 부모를 리턴.
     노드.removeChild(지울 자식 노드);                        // 지울 자식 노드에 해당하는 노드를 삭제


    


비동기 처리 (콜백)
    // 참고 자료 
    // https://springfall.cc/post/7
    // promise 비동기처리(callback)
    const iFlag = true;
    const promiseName = new Promise((resolve, reject)=>       // 함수 처리
    {
        // 비동기 성공시 resolve 호출
        // 비동기 실패시 reject 호출
        if(iFlag)
            resolve("콜백 성공");
        else
            reject("콜백 실패");
    })
    
    promiseName.then
    (   
      // resolve 호출 시 실행
      (resolveMessage)=>                                      // 함수 처리2
        console.log(resolveMessage)                           // then, .catch, .finally의 경우 세미콜론을 쓰면 안됨.
    )                                                            * 중괄호나 대괄호 안에서는 사용가능
    .catch
    (   
      //reject 호출 시 실행
      (errorMessage)=>                                        // 함수 처리3
        console.log(errorMessage)
    )
    .finally
    (   
      // 비동기 처리 후 무조건 실행됨.
      console.log("파이널")                                   // 비동기 처리가 완료된 후 작동하는게 아니라 실행됬으면
    )                                                            무조건 실행됨. (resolve나 reject보다 결과값이 먼저
                                                                                나올 수도 있음.)
    promise명.then(실행할 함수(){}, 실패시 실행할 함수(){})     // 이 방식으로도 예외 처리 가능.
    Promise.all(프로미스 배열명);                              // 배열에 있는 promise들을 전부 실행(동시에 비동기 실행)
                                                                * 전부 비동기 처리가 완료되야 resolve
                                                                * 하나라도 실패히 reject가 된다.


                                                              // 선언시             pending(대기)   상태
                                                                ex) new Promise;
                                                              // 동적할당 시 ?      Fulfilled(이행)  상태
                                                                ex) new Promise(함수);
                                                              // 실패하거나 오류 시  Recjected(실패)  상태

    async function 함수명()                                   // asyn는 Promise 객체를 반환함
    {                                                            * Promise가 코드가 난잡해져서 나온 최신 문법
      await 비동기처리 메서드 명()                             // await는 async내에서만 사용가능하고 Promise가 처리될때까지
    }                                                           기다렸다가 값을 반환함.
     ----------- 비동기 처리 (콜백)                               * then,catch에서 뭐가 성공인지 실패인지를 설정해야 가능 ?                        



json 형식
      * 기본적으로  key : value 형식으로 구성된 자료. 통신이나 저장같은데 사용함.
    JSON.stringify(문자열로 바꿀 json)                          // json을 문자열로 변환.
                                                                  ex)
                                                                      var json          = {"key" : "value"}
                                                                      var incodingData  = JSON.stringify(json);
     JSON.parse(json으로 바꿀 문자열)                           // json을 문자열로 변환. (문자열은 무조건 JSON 형태여야 됨)
                                                                  ex)
                                                                      var str           = '{"test" : "value"}';
                                                                      var parsingData   = JSON.parse(str);
    JSON명.push(제이슨형식 데이터 or 제이슨 데이터)               // 제이슨 데이터 추가
    delete JSON명.지울데이터                                    // 제이슨 데이터 추가

     - 제이슨 파일 형식
    {
      "employees": 
      [
        {
          "name": "Surim",
          "lastName": "Son"
        },
        {
          "name": "Someone",
          "lastName": "Huh"
        },
        {
          "name": "Someone else",
          "lastName": "Kim"
        } 
      ]
    }
    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 자바 스크립트 












  